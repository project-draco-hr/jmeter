{
  AssertionResult result=new AssertionResult(getName());
  byte[] responseData=response.getResponseData();
  if (responseData.length == 0) {
    return result.setResultForNull();
  }
  result.setFailure(false);
  result.setFailureMessage("");
  if (log.isDebugEnabled()) {
    log.debug(new StringBuffer("Validation is set to ").append(isValidating()).toString());
    log.debug(new StringBuffer("Whitespace is set to ").append(isWhitespace()).toString());
    log.debug(new StringBuffer("Tolerant is set to ").append(isTolerant()).toString());
  }
  Document doc=null;
  boolean isXML=JOrphanUtils.isXML(responseData);
  try {
    doc=XPathUtil.makeDocument(new ByteArrayInputStream(responseData),isValidating(),isWhitespace(),isNamespace(),isTolerant(),isQuiet(),showWarnings(),reportErrors(),isXML);
  }
 catch (  SAXException e) {
    log.debug("Caught sax exception: " + e);
    result.setError(isXML);
    result.setFailureMessage(new StringBuffer("SAXException: ").append(e.getMessage()).toString());
    return result;
  }
catch (  IOException e) {
    log.warn("Cannot parse result content",e);
    result.setError(isXML);
    result.setFailureMessage(new StringBuffer("IOException: ").append(e.getMessage()).toString());
    return result;
  }
catch (  ParserConfigurationException e) {
    log.warn("Cannot parse result content",e);
    result.setError(isXML);
    result.setFailureMessage(new StringBuffer("ParserConfigurationException: ").append(e.getMessage()).toString());
    return result;
  }
catch (  TidyException e) {
    result.setError(isXML);
    result.setFailureMessage(e.getMessage());
    return result;
  }
  if (doc == null || doc.getDocumentElement() == null) {
    result.setError(isXML);
    result.setFailureMessage("Document is null, probably not parsable");
    return result;
  }
  NodeList nodeList=null;
  final String pathString=getXPathString();
  try {
    XObject xObject=XPathAPI.eval(doc,pathString);
switch (xObject.getType()) {
case XObject.CLASS_NODESET:
      nodeList=xObject.nodelist();
    break;
case XObject.CLASS_BOOLEAN:
  if (!xObject.bool()) {
    result.setFailure(!isNegated());
    result.setFailureMessage("No Nodes Matched " + pathString);
  }
return result;
default :
result.setFailure(isXML);
result.setFailureMessage("Cannot understand: " + pathString);
return result;
}
}
 catch (TransformerException e) {
result.setError(isXML);
result.setFailureMessage(new StringBuffer("TransformerException: ").append(e.getMessage()).append(" for:").append(pathString).toString());
return result;
}
if (nodeList == null || nodeList.getLength() == 0) {
log.debug(new StringBuffer("nodeList null no match  ").append(pathString).toString());
result.setFailure(!isNegated());
result.setFailureMessage("No Nodes Matched " + pathString);
return result;
}
log.debug("nodeList length " + nodeList.getLength());
if (log.isDebugEnabled() & !isNegated()) {
for (int i=0; i < nodeList.getLength(); i++) log.debug(new StringBuffer("nodeList[").append(i).append("] ").append(nodeList.item(i)).toString());
}
result.setFailure(isNegated());
if (isNegated()) result.setFailureMessage("Specified XPath was found... Turn off negate if this is not desired");
return result;
}
