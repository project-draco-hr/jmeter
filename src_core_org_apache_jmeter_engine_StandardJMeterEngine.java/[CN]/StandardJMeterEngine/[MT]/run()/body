{
  log.info("Running the test!");
  running=true;
  SearchByClass<TestPlan> testPlan=new SearchByClass<TestPlan>(TestPlan.class);
  test.traverse(testPlan);
  Object[] plan=testPlan.getSearchResults().toArray();
  if (plan.length == 0) {
    System.err.println("Could not find the TestPlan!");
    log.error("Could not find the TestPlan!");
    System.exit(1);
  }
  if (((TestPlan)plan[0]).isSerialized()) {
    serialized=true;
  }
  JMeterContextService.startTest();
  try {
    PreCompiler compiler=new PreCompiler();
    test.traverse(compiler);
  }
 catch (  RuntimeException e) {
    log.error("Error occurred compiling the tree:",e);
    JMeterUtils.reportErrorToUser("Error occurred compiling the tree: - see log file");
    return;
  }
  SearchByClass<TestListener> testListeners=new SearchByClass<TestListener>(TestListener.class);
  test.traverse(testListeners);
  testListeners.getSearchResults().addAll(testList);
  testList.clear();
  testListenersSave=testListeners;
  if (!startListenersLater) {
    notifyTestListenersOfStart(testListeners);
  }
  test.traverse(new TurnElementsOn());
  if (startListenersLater) {
    notifyTestListenersOfStart(testListeners);
  }
  List<?> testLevelElements=new LinkedList<Object>(test.list(test.getArray()[0]));
  removeThreadGroups(testLevelElements);
  SearchByClass<ThreadGroup> searcher=new SearchByClass<ThreadGroup>(ThreadGroup.class);
  test.traverse(searcher);
  TestCompiler.initialize();
  Iterator<ThreadGroup> iter=searcher.getSearchResults().iterator();
  System.gc();
  ListenerNotifier notifier=new ListenerNotifier();
  JMeterContextService.getContext().setSamplingStarted(true);
  int groupCount=0;
  JMeterContextService.clearTotalThreads();
  startingGroups=true;
  while (running && iter.hasNext()) {
    groupCount++;
    ThreadGroup group=iter.next();
    int numThreads=group.getNumThreads();
    JMeterContextService.addTotalThreads(numThreads);
    boolean onErrorStopTest=group.getOnErrorStopTest();
    boolean onErrorStopTestNow=group.getOnErrorStopTestNow();
    boolean onErrorStopThread=group.getOnErrorStopThread();
    String groupName=group.getName();
    int rampUp=group.getRampUp();
    float perThreadDelay=((float)(rampUp * 1000) / (float)numThreads);
    log.info("Starting " + numThreads + " threads for group "+ groupName+ ". Ramp up = "+ rampUp+ ".");
    if (onErrorStopTest) {
      log.info("Test will stop on error");
    }
 else     if (onErrorStopTestNow) {
      log.info("Test will stop abruptly on error");
    }
 else     if (onErrorStopThread) {
      log.info("Thread will stop on error");
    }
 else {
      log.info("Thread will continue on error");
    }
    ListedHashTree threadGroupTree=(ListedHashTree)searcher.getSubTree(group);
    threadGroupTree.add(group,testLevelElements);
    for (int i=0; running && i < numThreads; i++) {
      final JMeterThread jmeterThread=new JMeterThread(cloneTree(threadGroupTree),this,notifier);
      jmeterThread.setThreadNum(i);
      jmeterThread.setThreadGroup(group);
      jmeterThread.setInitialContext(JMeterContextService.getContext());
      jmeterThread.setInitialDelay((int)(perThreadDelay * i));
      final String threadName=groupName + " " + (groupCount)+ "-"+ (i + 1);
      jmeterThread.setThreadName(threadName);
      scheduleThread(jmeterThread,group);
      jmeterThread.setEngine(this);
      jmeterThread.setOnErrorStopTest(onErrorStopTest);
      jmeterThread.setOnErrorStopTestNow(onErrorStopTestNow);
      jmeterThread.setOnErrorStopThread(onErrorStopThread);
      Thread newThread=new Thread(jmeterThread);
      newThread.setName(threadName);
      allThreads.put(jmeterThread,newThread);
      newThread.start();
    }
    if (serialized && iter.hasNext()) {
      log.info("Waiting for thread group: " + groupName + " to finish before starting next group");
      while (running && allThreads.size() > 0) {
        pause(1000);
      }
    }
  }
  if (running) {
    log.info("All threads have been started");
  }
 else {
    log.info("Test stopped - no more threads will be started");
  }
  startingGroups=false;
}
