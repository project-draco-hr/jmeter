{
  log.info("Running the test!");
  running=true;
  SearchByClass testPlan=new SearchByClass(TestPlan.class);
  test.traverse(testPlan);
  Object[] plan=testPlan.getSearchResults().toArray();
  if (plan.length == 0) {
    System.err.println("Could not find the TestPlan!");
    log.error("Could not find the TestPlan!");
    System.exit(1);
  }
  if (((TestPlan)plan[0]).isSerialized()) {
    serialized=true;
  }
  JMeterContextService.startTest();
  try {
    PreCompiler compiler=new PreCompiler();
    test.traverse(compiler);
  }
 catch (  RuntimeException e) {
    log.error("Error occurred compiling the tree:",e);
    JMeterUtils.reportErrorToUser("Error occurred compiling the tree: - see log file");
    return;
  }
  SearchByClass testListeners=new SearchByClass(TestListener.class);
  test.traverse(testListeners);
  testListeners.getSearchResults().addAll(testList);
  testList.clear();
  testListenersSave=testListeners;
  if (!startListenersLater) {
    notifyTestListenersOfStart(testListeners);
  }
  test.traverse(new TurnElementsOn());
  if (startListenersLater) {
    notifyTestListenersOfStart(testListeners);
  }
  List testLevelElements=new LinkedList(test.list(test.getArray()[0]));
  removeThreadGroups(testLevelElements);
  SearchByClass searcher=new SearchByClass(ThreadGroup.class);
  test.traverse(searcher);
  TestCompiler.initialize();
  Iterator iter=searcher.getSearchResults().iterator();
  System.gc();
  ListenerNotifier notifier=new ListenerNotifier();
  schedule_run=true;
  JMeterContextService.getContext().setSamplingStarted(true);
  int groupCount=0;
  JMeterContextService.clearTotalThreads();
  startingGroups=true;
  while (iter.hasNext()) {
    groupCount++;
    ThreadGroup group=(ThreadGroup)iter.next();
    int numThreads=group.getNumThreads();
    JMeterContextService.addTotalThreads(numThreads);
    boolean onErrorStopTest=group.getOnErrorStopTest();
    boolean onErrorStopThread=group.getOnErrorStopThread();
    String groupName=group.getName();
    int rampUp=group.getRampUp();
    float perThreadDelay=((float)(rampUp * 1000) / (float)numThreads);
    log.info("Starting " + numThreads + " threads for group "+ groupName+ ". Ramp up = "+ rampUp+ ".");
    if (onErrorStopTest) {
      log.info("Test will stop on error");
    }
 else     if (onErrorStopThread) {
      log.info("Thread will stop on error");
    }
 else {
      log.info("Thread will continue on error");
    }
    ListedHashTree threadGroupTree=(ListedHashTree)searcher.getSubTree(group);
    threadGroupTree.add(group,testLevelElements);
    for (int i=0; running && i < numThreads; i++) {
      final JMeterThread jmeterThread=new JMeterThread(cloneTree(threadGroupTree),this,notifier);
      jmeterThread.setThreadNum(i);
      jmeterThread.setThreadGroup(group);
      jmeterThread.setInitialContext(JMeterContextService.getContext());
      jmeterThread.setInitialDelay((int)(perThreadDelay * i));
      final String threadName=groupName + " " + (groupCount)+ "-"+ (i + 1);
      jmeterThread.setThreadName(threadName);
      scheduleThread(jmeterThread,group);
      jmeterThread.setEngine(this);
      jmeterThread.setOnErrorStopTest(onErrorStopTest);
      jmeterThread.setOnErrorStopThread(onErrorStopThread);
      Thread newThread=new Thread(jmeterThread);
      newThread.setName(threadName);
      allThreads.put(jmeterThread,newThread);
      if (serialized && !iter.hasNext() && i == numThreads - 1) {
        serialized=false;
      }
      newThread.start();
    }
    schedule_run=false;
    if (serialized) {
      while (running && allThreads.size() > 0) {
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
  startingGroups=false;
}
