{
  SampleResult sresult=new SampleResult();
  String rlabel=getConstructorString();
  if (rlabel.length() == 0) {
    rlabel=JUnitSampler.class.getName();
  }
  sresult.setSampleLabel(getName());
  final String methodName=getMethod();
  final String className=getClassname();
  sresult.setSamplerData(className + "." + methodName);
  if (this.TEST_OBJECT == null) {
    this.TEST_OBJECT=getClassInstance(className,rlabel);
  }
  if (this.TEST_OBJECT != null) {
    initMethodObjects(this.TEST_OBJECT);
    final Method m=getMethod(this.TEST_OBJECT,methodName);
    TestResult tr=new TestResult();
    long timeout=0L;
    Class<? extends Throwable> expectedException=null;
    if (getJunit4()) {
      try {
        TEST_INSTANCE=new AnnotatedTestCase();
      }
 catch (      SecurityException e) {
        log.error(e.getLocalizedMessage(),e);
        return sresult;
      }
catch (      NoSuchMethodException e) {
        log.error(e.getLocalizedMessage(),e);
        return sresult;
      }
      Test annotation=m.getAnnotation(Test.class);
      if (null != annotation) {
        expectedException=annotation.expected();
        timeout=annotation.timeout();
      }
    }
 else {
      this.TEST_INSTANCE=(TestCase)this.TEST_OBJECT;
    }
    this.TEST_INSTANCE.setName(methodName);
    try {
      if (!getDoNotSetUpTearDown() && SETUP_METHOD != null) {
        try {
          SETUP_METHOD.invoke(this.TEST_OBJECT,new Object[0]);
        }
 catch (        InvocationTargetException e) {
          tr.addFailure(this.TEST_INSTANCE,new AssertionFailedError(e.getMessage()));
        }
catch (        IllegalAccessException e) {
          tr.addFailure(this.TEST_INSTANCE,new AssertionFailedError(e.getMessage()));
        }
catch (        IllegalArgumentException e) {
          tr.addFailure(this.TEST_INSTANCE,new AssertionFailedError(e.getMessage()));
        }
      }
      final TestCase theClazz=this.TEST_INSTANCE;
      tr.startTest(this.TEST_INSTANCE);
      sresult.sampleStart();
      Throwable thrown=null;
      if (getJunit4()) {
        try {
          theClazz.runBare();
        }
 catch (        Throwable t) {
          thrown=t;
        }
      }
 else {
        Protectable p=new Protectable(){
          public void protect() throws Throwable {
            m.invoke(theClazz,new Object[0]);
          }
        }
;
        tr.runProtected(theClazz,p);
      }
      tr.endTest(this.TEST_INSTANCE);
      sresult.sampleEnd();
      if (getJunit4()) {
        if (null == thrown) {
          if (expectedException != None.class) {
            tr.addFailure(this.TEST_INSTANCE,new AssertionFailedError("No error was generated for a test case which specifies an error."));
            throw new Exception("Unexpected lack of exception from the test case: " + getMethod());
          }
 else {
          }
        }
 else {
          thrown=thrown.getCause();
          if (expectedException.isAssignableFrom(thrown.getClass())) {
            log.debug("Test passed for " + getMethod());
          }
 else {
            tr.addFailure(this.TEST_INSTANCE,new AssertionFailedError("The wrong exception was thrown from the test case"));
            throw new Exception("The wrong exception was thrown from the test case");
          }
        }
        if (timeout > 0L && timeout < sresult.getTime()) {
          tr.addFailure(this.TEST_INSTANCE,new AssertionFailedError("Test took longer than speficied timeout."));
        }
      }
      if (!getDoNotSetUpTearDown() && TDOWN_METHOD != null) {
        TDOWN_METHOD.invoke(TEST_OBJECT,new Object[0]);
      }
    }
 catch (    InvocationTargetException e) {
      sresult.setResponseCode(getErrorCode());
      sresult.setResponseMessage(getError());
      sresult.setResponseData(e.getMessage().getBytes());
      sresult.setSuccessful(false);
    }
catch (    IllegalAccessException e) {
      sresult.setResponseCode(getErrorCode());
      sresult.setResponseMessage(getError());
      sresult.setResponseData(e.getMessage().getBytes());
      sresult.setSuccessful(false);
    }
catch (    ComparisonFailure e) {
      sresult.setResponseCode(getErrorCode());
      sresult.setResponseMessage(getError());
      sresult.setResponseData(e.getMessage().getBytes());
      sresult.setSuccessful(false);
    }
catch (    IllegalArgumentException e) {
      sresult.setResponseCode(getErrorCode());
      sresult.setResponseMessage(getError());
      sresult.setResponseData(e.getMessage().getBytes());
      sresult.setSuccessful(false);
    }
catch (    Exception e) {
      sresult.setResponseCode(getErrorCode());
      sresult.setResponseMessage(getError());
      sresult.setResponseData(e.getMessage().getBytes());
      sresult.setSuccessful(false);
    }
catch (    Throwable e) {
      sresult.setResponseCode(getErrorCode());
      sresult.setResponseMessage(getError());
      sresult.setResponseData(e.getMessage().getBytes());
      sresult.setSuccessful(false);
    }
    if (!tr.wasSuccessful()) {
      sresult.setSuccessful(false);
      StringBuffer buf=new StringBuffer();
      buf.append(getFailure());
      Enumeration<?> en=tr.errors();
      while (en.hasMoreElements()) {
        Object item=en.nextElement();
        if (getAppendError() && item instanceof TestFailure) {
          buf.append("Trace -- ");
          buf.append(((TestFailure)item).trace());
          buf.append("Failure -- ");
          buf.append(((TestFailure)item).toString());
        }
 else         if (getAppendException() && item instanceof Throwable) {
          buf.append(((Throwable)item).getMessage());
        }
      }
      sresult.setResponseMessage(buf.toString());
      sresult.setRequestHeaders(buf.toString());
      sresult.setResponseCode(getFailureCode());
    }
 else {
      sresult.setSuccessful(true);
      sresult.setResponseMessage(getSuccess());
      sresult.setResponseCode(getSuccessCode());
      sresult.setResponseData("Not Applicable".getBytes());
    }
  }
 else {
    sresult.setSuccessful(false);
    sresult.setResponseMessage("failed to create an instance of the class");
  }
  sresult.setBytes(0);
  sresult.setContentType("text");
  sresult.setDataType("Not Applicable");
  sresult.setRequestHeaders("Not Applicable");
  return sresult;
}
