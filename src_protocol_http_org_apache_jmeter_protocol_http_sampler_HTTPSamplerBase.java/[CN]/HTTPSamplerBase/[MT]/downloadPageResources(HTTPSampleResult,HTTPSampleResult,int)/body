{
  Iterator<URL> urls=null;
  try {
    final byte[] responseData=res.getResponseData();
    if (responseData.length > 0) {
      String parserName=getParserClass(res);
      if (parserName != null) {
        final HTMLParser parser=parserName.length() > 0 ? HTMLParser.getParser(parserName) : HTMLParser.getParser();
        String userAgent=getUserAgent(res);
        urls=parser.getEmbeddedResourceURLs(userAgent,responseData,res.getURL(),res.getDataEncodingWithDefault());
      }
    }
  }
 catch (  HTMLParseException e) {
    res.addSubResult(errorResult(e,new HTTPSampleResult(res)));
    setParentSampleSuccess(res,false);
  }
  if (urls != null && urls.hasNext()) {
    if (container == null) {
      container=new HTTPSampleResult(res);
      container.addRawSubResult(res);
    }
    res=container;
    String re=getEmbeddedUrlRE();
    Perl5Matcher localMatcher=null;
    Pattern pattern=null;
    if (re.length() > 0) {
      try {
        pattern=JMeterUtils.getPattern(re);
        localMatcher=JMeterUtils.getMatcher();
      }
 catch (      MalformedCachePatternException e) {
        log.warn("Ignoring embedded URL match string: " + e.getMessage());
      }
    }
    final List<Callable<AsynSamplerResultHolder>> liste=new ArrayList<Callable<AsynSamplerResultHolder>>();
    while (urls.hasNext()) {
      Object binURL=urls.next();
      try {
        URL url=(URL)binURL;
        if (url == null) {
          log.warn("Null URL detected (should not happen)");
        }
 else {
          String urlstr=url.toString();
          String urlStrEnc=encodeSpaces(urlstr);
          if (!urlstr.equals(urlStrEnc)) {
            try {
              url=new URL(urlStrEnc);
            }
 catch (            MalformedURLException e) {
              res.addSubResult(errorResult(new Exception(urlStrEnc + " is not a correct URI"),new HTTPSampleResult(res)));
              setParentSampleSuccess(res,false);
              continue;
            }
          }
          if (pattern != null && localMatcher != null && !localMatcher.matches(urlStrEnc,pattern)) {
            continue;
          }
          if (isConcurrentDwn()) {
            liste.add(new ASyncSample(url,HTTPConstants.GET,false,frameDepth + 1,getCookieManager(),this));
          }
 else {
            HTTPSampleResult binRes=sample(url,HTTPConstants.GET,false,frameDepth + 1);
            res.addSubResult(binRes);
            setParentSampleSuccess(res,res.isSuccessful() && (binRes != null ? binRes.isSuccessful() : true));
          }
        }
      }
 catch (      ClassCastException e) {
        res.addSubResult(errorResult(new Exception(binURL + " is not a correct URI"),new HTTPSampleResult(res)));
        setParentSampleSuccess(res,false);
        continue;
      }
    }
    if (isConcurrentDwn()) {
      int poolSize=CONCURRENT_POOL_SIZE;
      try {
        poolSize=Integer.parseInt(getConcurrentPool());
      }
 catch (      NumberFormatException nfe) {
        log.warn("Concurrent download resources selected, " + "but pool size value is bad. Use default value");
      }
      final String parentThreadName=Thread.currentThread().getName();
      final ThreadPoolExecutor exec=new ThreadPoolExecutor(poolSize,poolSize,KEEPALIVETIME,TimeUnit.SECONDS,new LinkedBlockingQueue<Runnable>(),new ThreadFactory(){
        @Override public Thread newThread(        final Runnable r){
          Thread t=new CleanerThread(new Runnable(){
            @Override public void run(){
              try {
                r.run();
              }
  finally {
                ((CleanerThread)Thread.currentThread()).notifyThreadEnd();
              }
            }
          }
);
          t.setName(parentThreadName + "-ResDownload-" + t.getName());
          t.setDaemon(true);
          return t;
        }
      }
);
      boolean tasksCompleted=false;
      try {
        final List<Future<AsynSamplerResultHolder>> retExec=exec.invokeAll(liste);
        exec.shutdown();
        exec.awaitTermination(AWAIT_TERMINATION_TIMEOUT,TimeUnit.SECONDS);
        CookieManager cookieManager=getCookieManager();
        for (        Future<AsynSamplerResultHolder> future : retExec) {
          AsynSamplerResultHolder binRes;
          try {
            binRes=future.get(1,TimeUnit.MILLISECONDS);
            if (cookieManager != null) {
              CollectionProperty cookies=binRes.getCookies();
              PropertyIterator iter=cookies.iterator();
              while (iter.hasNext()) {
                Cookie cookie=(Cookie)iter.next().getObjectValue();
                cookieManager.add(cookie);
              }
            }
            res.addSubResult(binRes.getResult());
            setParentSampleSuccess(res,res.isSuccessful() && (binRes.getResult() != null ? binRes.getResult().isSuccessful() : true));
          }
 catch (          TimeoutException e) {
            errorResult(e,res);
          }
        }
        tasksCompleted=exec.awaitTermination(1,TimeUnit.MILLISECONDS);
      }
 catch (      InterruptedException ie) {
        log.warn("Interruped fetching embedded resources",ie);
      }
catch (      ExecutionException ee) {
        log.warn("Execution issue when fetching embedded resources",ee);
      }
 finally {
        if (!tasksCompleted) {
          exec.shutdownNow();
        }
      }
    }
  }
  return res;
}
