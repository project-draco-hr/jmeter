{
  Message message=null;
  SampleResult res=new SampleResult();
  res.setSampleLabel(getName());
  boolean isOK=false;
  SendMailCommand instance=new SendMailCommand();
  instance.setSmtpServer(getPropertyAsString(SmtpSampler.SERVER));
  instance.setSmtpPort(getPropertyAsString(SmtpSampler.SERVER_PORT));
  instance.setUseSSL(getPropertyAsBoolean(USE_SSL));
  instance.setUseStartTLS(getPropertyAsBoolean(USE_STARTTLS));
  instance.setTrustAllCerts(getPropertyAsBoolean(SSL_TRUST_ALL_CERTS));
  instance.setEnforceStartTLS(getPropertyAsBoolean(ENFORCE_STARTTLS));
  instance.setUseAuthentication(getPropertyAsBoolean(USE_AUTH));
  instance.setUsername(getPropertyAsString(USERNAME));
  instance.setPassword(getPropertyAsString(PASSWORD));
  instance.setUseLocalTrustStore(getPropertyAsBoolean(USE_LOCAL_TRUSTSTORE));
  instance.setTrustStoreToUse(getPropertyAsString(TRUSTSTORE_TO_USE));
  instance.setEmlMessage(getPropertyAsString(EML_MESSAGE_TO_SEND));
  instance.setUseEmlMessage(getPropertyAsBoolean(USE_EML));
  instance.setEnableDebug(getPropertyAsBoolean(ENABLE_DEBUG));
  if (getPropertyAsString(MAIL_FROM).matches(".*@.*")) {
    instance.setSender(getPropertyAsString(MAIL_FROM));
  }
  final String receiverTo=getPropertyAsString(SmtpSampler.RECEIVER_TO).trim();
  final String receiverCC=getPropertyAsString(SmtpSampler.RECEIVER_CC).trim();
  final String receiverBcc=getPropertyAsString(SmtpSampler.RECEIVER_BCC).trim();
  try {
    instance.setReceiverTo(getPropNameAsAddresses(receiverTo));
    instance.setReceiverCC(getPropNameAsAddresses(receiverCC));
    instance.setReceiverBCC(getPropNameAsAddresses(receiverBcc));
    instance.setSubject(getPropertyAsString(SUBJECT) + (getPropertyAsBoolean(INCLUDE_TIMESTAMP) ? " <<< current timestamp: " + new Date().getTime() + " >>>" : ""));
    if (!getPropertyAsBoolean(USE_EML)) {
      instance.setMailBody(getPropertyAsString(MESSAGE));
      final String filesToAttach=getPropertyAsString(ATTACH_FILE);
      if (!filesToAttach.equals("")) {
        String[] attachments=filesToAttach.split(FILENAME_SEPARATOR);
        for (        String attachment : attachments) {
          instance.addAttachment(new File(attachment));
        }
      }
    }
    instance.setSynchronousMode(true);
    message=instance.prepareMessage();
    if (getPropertyAsBoolean(MESSAGE_SIZE_STATS)) {
      CounterOutputStream cs=new CounterOutputStream();
      message.writeTo(cs);
      res.setBytes(cs.getCount());
    }
 else {
      res.setBytes(-1);
    }
  }
 catch (  AddressException ex) {
    log.warn("Error while preparing message",ex);
    res.setResponseCode("500");
    res.setResponseMessage(ex.toString());
    return res;
  }
catch (  IOException ex) {
    log.warn("Error while preparing message",ex);
    res.setResponseCode("500");
    res.setResponseMessage(ex.toString());
    return res;
  }
catch (  MessagingException ex) {
    log.warn("Error while preparing message",ex);
    res.setResponseCode("500");
    res.setResponseMessage(ex.toString());
    return res;
  }
  res.sampleStart();
  try {
    instance.execute(message);
    res.setSamplerData("To: " + receiverTo + "\nCC: "+ receiverCC+ "\nBCC: "+ receiverBcc);
    res.setDataType(SampleResult.TEXT);
    res.setResponseCodeOK();
    res.setResponseMessage("Message successfully sent!\n" + instance.getServerResponse());
    isOK=true;
  }
 catch (  AuthenticationFailedException afex) {
    log.warn("",afex);
    res.setResponseCode("500");
    res.setResponseMessage("AuthenticationFailedException: authentication failed - wrong username / password!\n" + afex);
  }
catch (  MessagingException mex) {
    log.warn("",mex);
    res.setResponseCode("500");
    if (mex.getMessage().matches(".*Could not connect to SMTP host.*465.*") && mex.getCause().getMessage().matches(".*Connection timed out.*")) {
      res.setResponseMessage("MessagingException: Probably, SSL is not supported by the SMTP-Server!\n" + mex);
    }
 else     if (mex.getMessage().matches(".*StartTLS failed.*")) {
      res.setResponseMessage("MessagingException: StartTLS not supported by server or initializing failed!\n" + mex);
    }
 else     if (mex.getMessage().matches(".*send command to.*") && mex.getCause().getMessage().matches(".*unable to find valid certification path to requested target.*")) {
      res.setResponseMessage("MessagingException: Server certificate not trusted - perhaps you have to restart JMeter!\n" + mex);
    }
 else {
      res.setResponseMessage("Other MessagingException: " + mex.toString());
    }
  }
catch (  Exception ex) {
    log.warn("",ex);
    res.setResponseCode("500");
    if (null != ex.getMessage() && ex.getMessage().matches("Failed to build truststore")) {
      res.setResponseMessage("Failed to build truststore - did not try to send mail!");
    }
 else {
      res.setResponseMessage("Other Exception: " + ex.toString());
    }
  }
  res.sampleEnd();
  try {
    InputStream is=message.getInputStream();
    StringBuffer sb=new StringBuffer();
    byte[] buf=new byte[1024];
    int read=is.read(buf);
    while (read > 0) {
      sb.append(new String(buf,0,read));
      read=is.read(buf);
    }
    res.setResponseData(sb.toString().getBytes());
  }
 catch (  IOException ex) {
    log.warn("",ex);
  }
catch (  MessagingException ex) {
    log.warn("",ex);
  }
  res.setSuccessful(isOK);
  return res;
}
